

#' Neural Network Plotting - Internal Function
#'  
#' 
#' The \code{plotNet} is the internal function that implements the
#'  Neural Network Plotting routine.
#' 
#' This function,  with a Neural Network, a Prediction Index and a Confusion Matrix, generated by \code{\link{gui_vms_met_pred}},
#'  plots the graphical overall result of the neural network prediction.
#'   
#' 
#' @return This function does not return a value. 
#' 
#' @param net The Neural Network
#' @param Dg The Prediction Index
#' @param ConfMat The Confusion Matrix
#' 
#' @usage plotNet(net, Dg, ConfMat)
#'
#'
#'@references free text reference Pointers to the literature related to this object.
#'@seealso \code{\link{gui_vms_met_pred}}
#' @name plotNet

plotNet <- function(net,Dg,ConfMat){
  TrErr <- net$Merror[,1]
  VaErr <- net$Merror[,2]
  
  min <- min(ConfMat)
  max <- max(ConfMat)
  yLabels <- rownames(ConfMat)
  xLabels <- colnames(ConfMat)
  title <-c("Confusion Matrix")
  # Red and green range from 0 to 1 while Blue ranges from 1 to 0
  ColorRamp <- rgb( seq(0,1,length=256),  # Red
                    seq(0,1,length=256),  # Green
                    seq(1,0,length=256))  # Blue
  ColorLevels <- seq(min, max, length=length(ColorRamp))
  # Reverse Y axis
  reverse <- nrow(ConfMat) : 1
  yLabels <- yLabels[reverse]
  ConfMat <- ConfMat[reverse,]
  
  
  #Define layout
  layout(matrix(data=c(1,2,1,3), nrow=2, ncol=2), widths=c(4,1,4,1), heights=c(4,4))
  #Plot Error
  par(las=2)
  plot(TrErr, type="l",
       ylim=c(0,1.1*max(net$Merror)),
       lwd=2,col=2,
       xlab="Iteration",
       ylab="Mean Error")
  lines(VaErr,lwd=2,col=4)
  legend(0,#0.8*length(TrErr), 
         y = 0.6*max(net$Merror), 
         legend = c("Training","Validation"), 
         fill = c(2,4), col = c(2,4),cex=0.8)
  #Plot Conf Mat
  # Data Map
  par(mar = c(7,11,2,4),las=2)
  image(1:length(xLabels), 1:length(yLabels), t(ConfMat), col=ColorRamp, xlab="",
        ylab="", axes=FALSE, zlim=c(min,max))
  if( !is.null(title) ){
    title(main=title)
  }
  axis(BELOW<-1, at=1:length(xLabels), labels=xLabels, cex.axis=0.7)
  axis(LEFT <-2, at=1:length(yLabels), labels=yLabels, las= HORIZONTAL<-1,
       cex.axis=0.7)
  
  # Color Scale
  par(mar = c(3,2.5,2.5,2))
  image(1, ColorLevels,
        matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1),
        col=ColorRamp,
        xlab="",ylab="",
        xaxt="n")
}

StandardizeByCol <- function(xdata){
  ncolx <- ncol(xdata)
  for(ij in 1:ncolx){
    minx <- min(xdata[,ij],na.rm=TRUE)
    maxx <- max(xdata[,ij],na.rm=TRUE)
    xdata[,ij] <- (xdata[,ij] - minx)/(maxx-minx)
  } 
  return(xdata)
}


#' Shape File Data Joining - Internal Function
#'  
#' 
#' The \code{Join2shp} is the internal function that implements the
#'  Shape File Data Joining routine.
#' 
#' This function,  with a Grid Shape File, an Effort Count Vector and a File Destination Directory,
#'  (see \code{\link{gui_out_grid}}),
#'  creates a new Grid Shape File annotated with the Effort Count Vector.
#'   
#' 
#' @return This function does not return a value. 
#' 
#' @param shpfile The Original Grid Shape File
#' @param datavector The Effort Count Vector
#' @param dirdest The File Destination Directory
#' 
#' @usage Join2shp(shpfile, datavector, dirdest)
#'
#'
#'@references free text reference Pointers to the literature related to this object.
#'@seealso \code{\link{gui_out_grid}}
#' @name Join2shp

Join2shp <- function(shpfile, datavector, dirdest)
{
	sys_typ <- ifelse(.Platform$OS.type == "windows", "\\\\" , "/")
  diror <- paste(unlist(strsplit(shpfile, sys_typ))[1:length(unlist(strsplit(shpfile, sys_typ)))-1], collapse = sys_typ)
  if(diror == dirdest)
  {
    dirdest <- paste(dirdest, sys_typ, "grid", sep = "")
    dir.create(dirdest)
  }
  file_anm <- unlist(strsplit(unlist(strsplit(shpfile, sys_typ))[length(unlist(strsplit(shpfile, sys_typ)))], "[.]"))[1]
  
  otherfiles <- dir(diror)
  otherfiles <- otherfiles[grep(file_anm, otherfiles)]
  
  new_name <- ginput("Enter a name for\n the new shp file", title = "Shp File Name")
  
  for(iff in 1:length(otherfiles))
  {
    file.copy(from = paste(diror, sys_typ, otherfiles[iff], sep = "", collapse = ""), 
             to = paste(dirdest, sys_typ, new_name, ".", unlist(strsplit(otherfiles[iff], "[.]"))[length(unlist(strsplit(otherfiles[iff], "[.]")))], sep = "", collapse = ""))      
  }    
  dbfdata <- read.dbf(paste(diror, sys_typ,file_anm, ".dbf", sep = ""), as.is = TRUE)
  
  dbfdata$Count <- datavector
  
  write.dbf(dbfdata, paste(dirdest, sys_typ, new_name, ".dbf", sep = "", collapse = ""))
}

# Original spline basis
H0 = function(x) return(2*x^3-3*x^2+1)
H1 = function(x) return(-2*x^3+3*x^2)
H2 = function(x) return(x^3-2*x^2+x)
H3 = function(x) return(x^3-x^2)
# Derivatives
dH0 = function(x) return(6*x^2 - 6*x)
dH1 = function(x) return(-6*x^2 + 6*x)
dH2 = function(x) return(3*x^2 - 4*x + 1)
dH3 = function(x) return(3*x^2 - 2*x)

# # Original spline basis
# H0 = function(x) return((2*x^3)-(3*x^2)+1)
# H1 = function(x) return(-(2*x^3)+(3*x^2)
# H2 = function(x) return((x^3)-(2*x^2)+x)
# H3 = function(x) return((x^3)-(x^2))
# 
# # Derivatives
# dH0 = function(x) return((6*x^2) - (6*x))
# dH1 = function(x) return(-(6*x^2) + (6*x))
# dH2 = function(x) return((3*x^2) - (4*x) + 1)
# dH3 = function(x) return((3*x^2) - (2*x))


recu_dep <- function(xmin, xmax, ymin, ymax, resolut = 2, the_db = "")
{
	if(the_db != "")
	{
	
  co_ce <- fn$sqldf("select count(*) from intrp where LON > `xmin` and LON < `xmax` and LAT > `ymin` and LAT < `ymax`", dbname = the_db)
  
  if(co_ce[1,1] == 0)
  {
    cat("\n   -     Skipped block: x(", xmin, ",",xmax, ")*y(",ymin,",",ymax,")     -\n", sep = "")
  }else{
    xrange = c(xmin, xmax)
    yrange = c(ymin, ymax)
    # 	map("worldHires", xlim = xrange, ylim = yrange, bg = "darkorange2", col = "black", fill = T)
    # 	map.axes()
    l_x <- xmax - xmin
    l_y <- ymax - ymin
    if(l_x <= 0.25 | l_y <= 0.25)
    {
      cat("\n   -     New valid block: x(", xmin, ",",xmax, ")*y(",ymin,",",ymax,")     -\n", sep = "")
      deppoi <- fn$sqldf("select ROWID, * from intrp where LON > `xmin` and LON < `xmax` and LAT > `ymin` and LAT < `ymax`", dbname = the_db)
      
      cat("\n   -     Analyzing ", nrow(deppoi), " points     -\n\n", sep = "")
      
      bat_blo <- getmarmap.bathy(xmin-0.1,
                               xmax+0.1,
                               ymin-0.1,
                               ymax+0.1, resolution = resolut)
      plot(bat_blo, image = T)
      points(deppoi[,"LON"], deppoi[,"LAT"], pch = 20, col = "firebrick")
      
      xlon <- rep(as.numeric(rownames(bat_blo)),length(as.numeric(colnames(bat_blo))))
      ylat <- rep(as.numeric(colnames(bat_blo)),each=length(as.numeric(rownames(bat_blo))))
      zdep <- as.numeric(bat_blo)
      cat("\n   -     Calculating Spline...     -", sep = "")
      SplineD <- Tps(cbind(xlon, ylat), zdep, lon.lat=TRUE)
      rm(bat_blo, zdep, xlon, ylat)
      cat("\n   -     Predicting depth", sep = "")
      if(nrow(deppoi)<= 10000){
        cat(" ", sep = "")
        dept <- as.numeric(predict(SplineD, deppoi[,c("LON","LAT")]))
        dep_v <- as.data.frame(cbind(deppoi[,"rowid"], deppoi[,"I_NCEE"], dept))
        sqldf("insert into p_depth select * from `dep_v`", dbname = the_db)
        rm(dept, dep_v)
        gc()
      }else{
        nPin <- ceiling(nrow(deppoi)/10000)
        for(pi in 1:nPin)
        {
          cat(".", sep = "")
          r1 <- 10000*(pi-1)+1
          r2 <- min(nrow(deppoi),r1+10000-1)
          dept <- as.numeric(predict(SplineD, deppoi[r1:r2,c("LON","LAT")]))
          dep_v <- as.data.frame(cbind(deppoi[r1:r2,"rowid"], deppoi[r1:r2,"I_NCEE"], dept))
          sqldf("insert into p_depth select * from `dep_v`", dbname = the_db)
          rm(dept, dep_v)
          gc()
        }            
      }
      cat(" - Completed!     -\n", sep = "")
      rm(SplineD)
      gc()
    }else{
      xmin_2 <- xmin+((xmax-xmin)/2)
      ymin_2 <- ymin+((ymax-ymin)/2)
      cat("\n   -     Splitting block...     -\n", sep = "")
      recu_dep(xmin, xmin_2, ymin, ymin_2, resolut = resolut, the_db)
      recu_dep(xmin_2, xmax, ymin, ymin_2, resolut = resolut, the_db)
      recu_dep(xmin, xmin_2, ymin_2, ymax, resolut = resolut, the_db)
      recu_dep(xmin_2, xmax, ymin_2, ymax, resolut = resolut, the_db)
    }
  }
  } else {
  cat("\n\n   -     Error! Bad Database File      -\n", sep = "")
  }
}

recu_dep_RDS <- function(bat_all, xmin, xmax, ymin, ymax, the_db = "", max_siz = 0.25, the_bbo)
{
  if(the_db != "")
  {
    
    co_ce <- fn$sqldf("select count(*) from intrp where LON >= `xmin` and LON <= `xmax` and LAT >= `ymin` and LAT <= `ymax`", dbname = the_db)
    
    if(co_ce[1,1] == 0)
    {
      cat("\n   -     Skipped block: x(", xmin, ",",xmax, ")*y(",ymin,",",ymax,")     -\n", sep = "")
    }else{
      xrange = c(xmin, xmax)
      yrange = c(ymin, ymax)
      l_x <- xmax - xmin
      l_y <- ymax - ymin
      if(l_x <= max_siz | l_y <= max_siz)
      {
        cat("\n   -     New valid block", sep = "")
        
        deppoi <- fn$sqldf("select ROWID, * from intrp where LON >= `xmin` and LON <= `xmax` and LAT >= `ymin` and LAT <= `ymax`", dbname = the_db)
        
        cat(" with ", nrow(deppoi), " points\t", sep = "")
        
        cur_rows <- which(as.numeric(rownames(bat_all)) >= xmin-0.1 & as.numeric(rownames(bat_all)) <= xmax+0.1)
        cur_cols <- which(as.numeric(colnames(bat_all)) >= ymin-0.1 & as.numeric(colnames(bat_all)) <= ymax+0.1)
        
        bat_blo <- bat_all[cur_rows, cur_cols]
        
        xlon <- rep(as.numeric(rownames(bat_blo)),length(as.numeric(colnames(bat_blo))))
        ylat <- rep(as.numeric(colnames(bat_blo)),each=length(as.numeric(rownames(bat_blo))))
        zdep <- as.numeric(bat_blo)
        
        plot(as.bathy(cbind(xlon, ylat, zdep)), image = T)
        points(deppoi[,"LON"], deppoi[,"LAT"], pch = 20, col = "firebrick")
        
        cat("   -   Calculating Spline...   ", sep = "")
        SplineD <- Tps(cbind(xlon, ylat), zdep, lon.lat=TRUE)
        rm(bat_blo, zdep, xlon, ylat)
        
        cat("Predicting depth...", sep = "")
        if(nrow(deppoi)<= 10000){
          dept <- as.numeric(predict(SplineD, deppoi[,c("LON","LAT")]))
          dep_v <- as.data.frame(cbind(deppoi[,"rowid"], deppoi[,"I_NCEE"], dept))
          sqldf("insert into p_depth select * from `dep_v`", dbname = the_db)
          rm(dept, dep_v)
          gc()
        }else{
          nPin <- ceiling(nrow(deppoi)/10000)
          for(pi in 1:nPin)
          {
            cat(".", sep = "")
            r1 <- 10000*(pi-1)+1
            r2 <- min(nrow(deppoi),r1+10000-1)
            dept <- as.numeric(predict(SplineD, deppoi[r1:r2,c("LON","LAT")]))
            dep_v <- as.data.frame(cbind(deppoi[r1:r2,"rowid"], deppoi[r1:r2,"I_NCEE"], dept))
            sqldf("insert into p_depth select * from `dep_v`", dbname = the_db)
            rm(dept, dep_v)
            gc()
          }            
        }
        cat(" - Completed!     -\n", sep = "")
        map("worldHires", xlim = the_bbo[2:1], ylim = the_bbo[4:3], bg = "darkorange2", col = "black", fill = T)
        map.axes()
        
        xmin_2 <- xmin+((xmax-xmin)/2)
        abline(v = xmin_2, col = "firebrick")
        ymin_2 <- ymin+((ymax-ymin)/2)
        abline(h = ymin_2, col = "firebrick")
        
        rect(xmin, ymin, xmin_2, ymin_2, border = "firebrick")
        rect(xmin_2, ymin, xmax, ymin_2, border = "firebrick")
        rect(xmin, ymin_2, xmin_2, ymax, border = "firebrick")
        rect(xmin_2, ymin_2, xmax, ymax, border = "firebrick")
        
        rm(SplineD)
        gc()
      }else{
        
        map("worldHires", xlim = the_bbo[2:1], ylim = the_bbo[4:3], bg = "darkorange2", col = "black", fill = T)
        map.axes()
        
        title("Splitting Block...")
        
        xmin_2 <- xmin+((xmax-xmin)/2)
        abline(v = xmin_2, col = "firebrick")
        ymin_2 <- ymin+((ymax-ymin)/2)
        abline(h = ymin_2, col = "firebrick")
        
        rect(xmin, ymin, xmin_2, ymin_2, border = "firebrick")
        rect(xmin_2, ymin, xmax, ymin_2, border = "firebrick")
        rect(xmin, ymin_2, xmin_2, ymax, border = "firebrick")
        rect(xmin_2, ymin_2, xmax, ymax, border = "firebrick")
        
        recu_dep_RDS(bat_all, xmin, xmin_2, ymin, ymin_2, the_db, max_siz, the_bbo)
        recu_dep_RDS(bat_all, xmin_2, xmax, ymin, ymin_2, the_db, max_siz, the_bbo)
        recu_dep_RDS(bat_all, xmin, xmin_2, ymin_2, ymax, the_db, max_siz, the_bbo)
        recu_dep_RDS(bat_all, xmin_2, xmax, ymin_2, ymax, the_db, max_siz, the_bbo)
      }
    }
  } else {
    cat("\n\n   -     Error! Bad Database File      -\n", sep = "")
  }
}

#' Assign Area - Internal Function
#'  
#' 
#' The \code{Assign_Area} is the internal function that implements the
#'  Assign Area routine.
#' 
#' This function,  with a VMS DB Track and a Sea Areas Shape File,
#'  (see \code{\link{gui_vms_db_are}}),
#'  finds the Sea Area that contain the VMS DB Track.
#'   
#' 
#' @return This function does not return a value. 
#' 
#' @param evnt The VMS Track Data
#' @param box The Sea Areas Shape File Box
#' 
#' @usage Assign_Area(evnt, box)
#'
#'
#'@references free text reference Pointers to the literature related to this object.
#'@seealso \code{\link{gui_vms_db_are}}
#' @name Assign_Area

Assign_Area = function(evnt, box){  
  Area <- max(findPolys(as.EventData(data.frame(EID = 1, X = mean(evnt[,1]), Y = mean(evnt[,2])), projection="LL"), box)[,2])
  if(length(Area) == 0) Area <- NA
  return(Area)
}


#' Effort Count - Internal Function
#'  
#' 
#' The \code{CountMap} is the internal function that implements the
#'  Effort Count routine.
#' 
#' This function,  with a VMS DB Track and a Sea Areas Shape File,
#'  (see \code{\link{gui_out_grid}}),
#'  computes the Effort Count Vector.
#'   
#' 
#' @return This function does not return a value. 
#' 
#' @param xy The VMS Fishing Point Data
#' @param GridPS The Sea Area Grid File
#' 
#' @usage CountMap(xy, GridPS)
#'
#'
#' @references free text reference Pointers to the literature related to this object.
#' @seealso \code{\link{gui_out_grid}}
#' @name CountMap

CountMap = function(xy, GridPS){
  PP=xy[,c(1:2)]
  GridCount = matrix(0,length(unique(GridPS$PID)),2)
  colnames(GridCount) = c("cellID","Count")
  if(nrow(PP)<= 100000){
    Poi=matrix(0,nrow(PP),3)
    colnames(Poi)=c("EID","X","Y")
    Poi[,1]=c(1:nrow(Poi))
    Poi[,2]=PP[,1]
    Poi[,3]=PP[,2]
    idPolys = findPolys(Poi, GridPS)
    idTable = table(idPolys[,2])
    GridCount[,1] = 1:length(unique(GridPS$PID))
    GridCount[as.numeric(names(idTable)),2] = as.numeric(idTable)
  }else{
    nPP <- ceiling(nrow(PP)/100000)
#     GridCount = matrix(0,length(unique(GridPS$PID)),2) 
    for(pi in 1:nPP){
      cat(".", sep = "")
      r1 <- 100000*(pi-1)+1
      r2 <- min(nrow(PP),r1+100000-1)
      Poi=matrix(0,r2-r1+1,3)
      colnames(Poi)=c("EID","X","Y")
      Poi[,1]=c(1:nrow(Poi))
      Poi[,2]=PP[r1:r2,1]
      Poi[,3]=PP[r1:r2,2]
      #GridPS = SpatialPolygons2PolySet(GSA)
      idPolys = findPolys(Poi, GridPS) #Supporta fino a 100.000 punti
      idTable = table(idPolys[,2])
      GridCount_part = matrix(0,length(unique(GridPS$PID)),2)
      colnames(GridCount_part) = c("cellID","Count")
      GridCount_part[,1] = 1:length(unique(GridPS$PID))
      GridCount_part[as.numeric(names(idTable)),2] = as.numeric(idTable)
      GridCount[,2]=GridCount[,2]+GridCount_part[,2]
    }
  }
  return(GridCount[,2])
}

getmarmap.bathy <- function (lon1, lon2, lat1, lat2, resolution = 4, keep = FALSE, 
          antimeridian = FALSE) {
  x1 = x2 = y1 = y2 = NULL
  if (lon1 < lon2) {
    x1 <- lon1
    x2 <- lon2
  }
  else {
    x2 <- lon1
    x1 <- lon2
  }
  if (lat1 < lat2) {
    y1 <- lat1
    y2 <- lat2
  }
  else {
    y2 <- lat1
    y1 <- lat2
  }
  res = resolution * 0.0166666666666667
  fetch <- function(x1, y1, x2, y2, res) {
    WEB.REQUEST <- paste("http://maps.ngdc.noaa.gov/mapviewer-support/wcs-proxy/wcs.groovy?filename=etopo1.xyz&request=getcoverage&version=1.0.0&service=wcs&coverage=etopo1&CRS=EPSG:4326&format=xyz&resx=", 
                         res, "&resy=", res, "&bbox=", x1, ",", y1, ",", x2, 
                         ",", y2, sep = "")
    dat <- suppressWarnings(try(read.table(WEB.REQUEST), 
                                silent = TRUE))
    return(dat)
  }
  if (antimeridian) {
    FILE <- paste("marmap_coord_", x1, ":", y1, ":", x2, 
                  ":", y2, "_res_", resolution, "_anti", ".csv", sep = "")
  }
  else {
    FILE <- paste("marmap_coord_", x1, ":", y1, ":", x2, 
                  ":", y2, "_res_", resolution, ".csv", sep = "")
  }
  if (FILE %in% list.files()) {
    cat("File already exists ; loading '", FILE, "'", sep = "")
    exisiting.bathy <- read.bathy(FILE, header = T)
    return(exisiting.bathy)
  }
  else {
    if (antimeridian) {
      l1 <- x2
      l2 <- 180
      l3 <- -180
      l4 <- x1
      cat("Querying NOAA database ...\n")
      cat("This may take seconds to minutes, depending on grid size\n")
      left <- fetch(l1, y1, l2, y2, res)
      right <- fetch(l3, y1, l4, y2, res)
      if (is(left, "try-error") | is(right, "try-error")) {
        stop("The NOAA server cannot be reached\n")
      }
      else {
        cat("Building bathy matrix ...\n")
        left <- as.bathy(left)
        left <- left[-nrow(left), ]
        right <- as.bathy(right)
        rownames(right) <- as.numeric(rownames(right)) + 
          360
        bath2 <- rbind(left, right)
        class(bath2) <- "bathy"
        bath <- as.xyz(bath2)
      }
    }
    else {
      cat("Querying NOAA database ...\n")
      cat("This may take seconds to minutes, depending on grid size\n")
      bath <- fetch(x1, y1, x2, y2, res)
      if (is(bath, "try-error")) {
        stop("The NOAA server cannot be reached\n")
      }
      else {
        cat("Building bathy matrix ...\n")
        bath2 <- as.bathy(bath)
      }
    }
    if (keep) {
      write.table(bath, file = FILE, sep = ",", quote = FALSE, 
                  row.names = FALSE)
    }
    return(bath2)
  }
}